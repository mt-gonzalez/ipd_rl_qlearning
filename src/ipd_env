import gymnasium as gym
from gymnasium import spaces
import numpy as np

class IteratedPrisonersDilemmaEnv(gym.Env):
    #It will be a default opponent strategy if a list of them isn't submitted
    def __init__(self, num_rounds=10, R=3, T=5, S=0, P=1, opponent_strategies=None):
        
        #Binary action space: Coop -> 0, Betray -> 1
        self.action_space = spaces.Discrete(2)

        #MultiDiscrete space: Array with Agent and Opponent decision
        self.observation_space = spaces.MultiDiscrete([2, 2])

        #Environment configuration
        self.num_rounds = num_rounds
        self.R, self.T, self.S, self.P = R, T, S, P #Reward, Temptation, Sucker, Penalty
        self.current_round = 0
        self.agent_history = []  #Agent decision history
        self.opponent_history = []  #Opponent decision history

        # Default strategy
        self.default_strategy = self.tit_for_tat

        if opponent_strategies is None:
            self.opponent_strategies = [self.default_strategy]
        else:
            self.opponent_strategies = opponent_strategies
        
        self.current_opponent = None  # Actual opponent strategy

        #Reward matrix (coop, betray)
        self.reward_matrix = {
            (0, 0): (self.R, self.R),  # Both coop
            (0, 1): (self.S, self.T),  # Agent coop, opponent defects
            (1, 0): (self.T, self.S),  # Agent defects, opponent coop
            (1, 1): (self.P, self.P)   # Both defect
        }

    def tit_for_tat(agent_last_action):
        """Copies last Agent decision. Coop if decide first."""
        return 0 if agent_last_action is None else agent_last_action

    #I want to get the agent last action, I will pass it in the .step method later.